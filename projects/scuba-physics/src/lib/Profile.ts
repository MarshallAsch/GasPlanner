import { Options } from './BuhlmannAlgorithm';
import { DepthConverter } from './depth-converter';
import { Gas } from './Gases';
import { Segment } from './Segments';

export enum EventType {
    noAction = 0,
    /** Generic error which prevents algorithm calculation */
    error = 1,
    /** Gas switch happened at this moment */
    gasSwitch = 2,
    /** At this moment, diver reached end of no deco limit */
    reachedNoDeco = 3,
    /** when breathing gas at this depth, it leads to Hypoxia */
    lowPpO2 = 3,
    /** breathing gas with high ppO2 can lead to oxygen toxicity */
    highPpO2 = 4
}

export class Event {
    /** The number of seconds since dive begin the event occurred */
    public timeStamp: number;
    /** depth in meters, at which the diver was, when the event occurred */
    public depth: number;
    /** purpose of the event to happen */
    public type: EventType;
    /** Optional explanation of the event or empty string */
    public message?: string;
    /** Optional data associated with the event, e.g. Gas for gas switch */
    public data?: any;
}

export class EventsFactory {
    public static createGasSwitch(timeStamp: number, depth: number, gas: Gas): Event {
        return {
            timeStamp: timeStamp,
            depth: depth,
            type: EventType.gasSwitch,
            data: gas
        };
    }

    public static createError(message: string): Event {
        return {
            timeStamp: 0,
            depth: 0,
            type: EventType.error,
            message: message
        };
    }

    public static createLowPpO2(depth: number): Event {
        return {
            timeStamp: 0,
            depth: depth,
            type: EventType.lowPpO2
        };
    }

    public static createHighPpO2(depth: number): Event {
        return {
            timeStamp: 0,
            depth: depth,
            type: EventType.highPpO2
        };
    }
}

export class Events {
    public items: Event[] = [];

    public add(event: Event): void {
       this.items.push(event);
    }
}

/** all values in bar */
class PressureSegment {
    constructor(
        public startDepth: number,
        public endDepth: number
    ) {}
    
    public get minDepth(): number {
        return Math.min(this.startDepth, this.endDepth)
    }

    public get maxDepth(): number {
        return Math.max(this.startDepth, this.endDepth)
    }
}

/** Creates events from profile generated by the algorithm */
export class ProfileEvents {
    public static createEvents(profile: CalculatedProfile, depthConverter: DepthConverter, options: Options): Events {
        const events: Events = new Events();
        let elapsed = 0;

        profile.segments.forEach((segment: Segment, index: number, items: Segment[]) => {
            const nextIndex = index + 1;

            this.addPpO2Events(events, segment, options.maxPpO2, depthConverter);

            elapsed += segment.duration;
            this.addGasSwitch(items, segment, nextIndex, elapsed, events);
            
        });      
        
        return events;
    }

    private static addGasSwitch(segments: Segment[], segment: Segment, nextIndex: number, elapsed: number, events: Events) {
        // needs to be done after current segment duration is counted
        if(nextIndex <= segments.length - 1) {
            const nextSegment: Segment = segments[nextIndex];

            if(!segment.gas.compositionEquals(nextSegment.gas)) {
                const gasSwitch = EventsFactory.createGasSwitch(elapsed, nextSegment.startDepth, nextSegment.gas);
                events.add(gasSwitch);
            }
        }
    }

    private static toPressureSegment(segment: Segment, depthConverter: DepthConverter) {
        const startPressure = depthConverter.toBar(segment.startDepth);
        const endPressure = depthConverter.toBar(segment.endDepth);
        return new PressureSegment(startPressure, endPressure);
    }

    private static addPpO2Events(events: Events, segment: Segment, maxPpo: number, depthConverter: DepthConverter): void {
        const pressureSegment = this.toPressureSegment(segment, depthConverter);
        const gasMod = segment.gas.mod(maxPpo);
        // nice to have calculate exact time and depth of the events, it is enough it happened

        if (pressureSegment.maxDepth > gasMod) {
            const highDepth = depthConverter.fromBar(gasMod);
            const highPpO2Event = EventsFactory.createHighPpO2(highDepth);
            events.add(highPpO2Event);
        }

        const gasCeiling = segment.gas.ceiling(depthConverter.surfacePressure);

        if (gasCeiling > pressureSegment.minDepth) {
            const lowDepth = depthConverter.fromBar(gasCeiling);
            const lowPpO2Event = EventsFactory.createLowPpO2(lowDepth);
            events.add(lowPpO2Event);
        }
    }

}

/**
 * Dive definition point in moment during the dive.
 */
export class Ceiling {
    /**
     * Gets or sets moment in seconds during the dive
     */
    public time: number;

    /**
     * Gets or sets the maximum safe depth to ascent to.
     */
    public depth: number;
}

/**
 * Result of the Algorithm calculation
 */
export class CalculatedProfile {
    /**
     * Not null collection of segments filled whole dive profile.
     */
    public get segments(): Segment[] {
        return this.seg;
    }

    /**
     * Not null collection of ceilings.
     */
    public get ceilings(): Ceiling[] {
       return this.ceil;
    }

    /**
     * Not null collection of errors occurred during the profile calculation.
     * If not empty, ceilings and segments are empty.
     */
    public get events(): Event[] {
        return this.evnt;
    }

    private constructor(private seg: Segment[], private ceil: Ceiling[], private evnt: Event[]) { }

    public static fromErrors(errors: Event[]) {
        return new CalculatedProfile([], [], errors);
    }

    public static fromProfile(segments: Segment[], ceilings: Ceiling[], events: Event[]) {
        return new CalculatedProfile(segments, ceilings, events);
    }
}
